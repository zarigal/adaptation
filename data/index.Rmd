---
title: "Redcedar Adaptation Data Wrangle Markdown"
output: html_document
date: "2025-08-07"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data Wrangling

## Purpose 

The purpose of this markdown document is to import, wrangle, and export the adaptation data for use in analyses and visualization. 

* The Data
  + 2022 Measurements (Pre-planting or just after planting)
  + 2023 Measurements (1 year after planting)
  + 2024 Measurements (2 years after planting)
  + 2025 Measurements (3 years after planting)
  
## Data Download

This webpage and data are hosted in a github repository. The content on this page is compiled using R Markdown, but the data is maintained as a .csv file.

Download the data by visiting: https://github.com/jmhulbert/adaptation

Anyone is welcome to collaborate to add or make changes to the github repository (https://github.com/jmhulbert/adaptation).

    As a repository collaborator:
        You are welcome to clone the repository to your system and work from the R Project file (adaptation.Rproj) in Rstudio or you can make changes to the .csv files (./data/).
        You can also make changes directly to the .csv file through your browser.
        Or you can make changes by downloading the .csv file, altering, committing and pushing it back to the repository.
        You can also drop new .csv files into the ./data/ folder in the repository.

Note that you need a github account to collaborate or make changes. Feel free to contact JM Hulbert for additional details and instructions, or to request a change or addition.

Note the Markdown (index.Rmd) file will need to be knit before the changes will be visible on this webpage.  

## Load packages
```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(kableExtra)
library(patchwork)
library(zoo)
library(readxl)
```

## Import data files
```{r message=FALSE, warning=FALSE}
y1 <- read_csv("2022 Measurements.csv")
y2 <- read_excel("2023 MeasurementsCorrected.xlsx")
y3 <- read_excel("2024 Measurementsv3.xlsx")
y4 <- read_excel("2025 Measurements.xlsx", sheet = "2025")
```

## Data Merging
Add measurement year column for each year's dataset.
```{r}
y1$Measurement.Year <- 2022
y2$Measurement.Year <- 2023
y3$Measurement.Year <- 2024
y4 <- cbind(y4, Measurement.Year= 2025)
```

Remove extra inconsistent columns between each year's dataset. Add "Temp Tree Numbers" for year 1 dataset and if "Health" column NA change to "Alive".
```{r}
y4 <- y4 %>% select(-c("Year Measured"))

#remove unnecessary columns
y1 <- y1 %>% select(-c("Year Measured","Color"))
y2 <- y2 %>% select(-c("Year Measured","Color"))
y3 <- y3 %>% select(-c("Year Measured"))

#add tree numbers for first year
y1 <- y1 %>% mutate(`Temp Tree Number` = row_number())

#in Year 1, if health condition is NA, change it to alive
y1 <- y1 %>%
  mutate(Health = ifelse(is.na(Health), "Alive", Health))
```

Make data format consistent between all years.
```{r}
#change date format to match year 4
y1$`Date Measured` <- as.Date(y1$`Date Measured`,format = "%m/%d/%y")
y1$`Date Planted` <- as.Date(y1$`Date Planted`,format = "%m/%d/%y")
y2$`Date Measured` <- as.Date(y2$`Date Measured`,format ="%m/%d/%y")
y3$`Date Measured` <- as.Date(y3$`Date Measured`,format ="%m/%d/%y")
y4$`Date Measured` <- as.Date(y4$`Date Measured`,format = "%m/%d/%y")
```

Merge all year's dataframes together.
```{r}
#bind all year dataframes together
trees.bind <- bind_rows(y1,y2) %>% bind_rows(.,y3) %>% bind_rows(.,y4) %>% filter(Site!="" & Site!="Puyallup") %>% droplevels()
```

Fix labeling inconsistencies within cells.
```{r}
#labeling consistency
trees.bind$Health[trees.bind$Health==""] <- "Missing"
trees.bind$Health[trees.bind$Health=="missing"] <- "Missing"
trees.bind$Health[trees.bind$Health == "dead"] <- "Dead"
trees.bind$`Seed Zone`[trees.bind$`Seed Zone`=="Wa"] <- "WA"
trees.bind <- trees.bind %>% droplevels()
```

Fill in "Elk Browsed" data based off "Comments" column. If comments column contain "browsed", mark 'Elk Browsed' column as 'Y' (yes), otherwise mark 'N' (no).
```{r}
#if comments contain "browsed", mark elk browsed column as Y, otherwise mark N
trees.bind <- trees.bind %>%
  mutate(`Elk Browse` = case_when(
    grepl("browsed", Comment, ignore.case = TRUE) ~ "Y",
    TRUE ~ "N" # Keep the original value if no match is found
  ))
```


```{r}
#use New Tree Number if not NA, otherwise use Tree Number
trees.bind <- trees.bind %>% group_by(`Tree Number`, Site, `Seed Zone`) %>% 
  mutate(`New Tree Number` = if_else(is.na(`New Tree Number`),first(na.omit(`New Tree Number`)),`New Tree Number`)) %>%
  ungroup()

#use Temp Tree Number if not NA, otherwise use Tree Number
trees.bind <- trees.bind %>% group_by(`Tree Number`, Site, `Seed Zone`) %>%
  mutate(`Temp Tree Number` = if_else(is.na(`Temp Tree Number`),first(na.omit(`Temp Tree Number`)),`Temp Tree Number`))%>%
  ungroup()

trees.bind <- trees.bind %>%  group_by(`Tree Number`, Site, `Seed Zone`) %>%
  mutate(`Date Planted` = if_else(is.na(`Date Planted`),first(na.omit(`Date Planted`)),`Date Planted`)) %>%
  ungroup()
#if comments contain "missing/presumed dead" change health condition to missing
trees.bind <- trees.bind %>%
  mutate(`Health` = case_when(
    grepl("Missing/presumed dead", Comment, ignore.case = TRUE) ~ "Missing",
    TRUE ~ `Health` # Keep the original value if no match is found
  ))

#use New Tree Number if not NA, otherwise use Tree Number
trees.bind <- trees.bind %>% group_by(`Tree Number`, Site, `Seed Zone`) %>% 
  mutate(`New Tree Number` = if_else(is.na(`New Tree Number`),first(na.omit(`New Tree Number`)),`New Tree Number`)) %>%
  ungroup()

#use Temp Tree Number if not NA, otherwise use Tree Number
trees.bind <- trees.bind %>% group_by(`Tree Number`, Site, `Seed Zone`) %>%
  mutate(`Temp Tree Number` = if_else(is.na(`Temp Tree Number`),first(na.omit(`Temp Tree Number`)),`Temp Tree Number`))%>%
  ungroup()

trees.bind <- trees.bind %>%  group_by(`Tree Number`, Site, `Seed Zone`) %>%
  mutate(`Date Planted` = if_else(is.na(`Date Planted`),first(na.omit(`Date Planted`)),`Date Planted`)) %>%
  ungroup()

trees.bind$`Date Measured` <- as.Date(trees.bind$`Date Measured`,"%m/%d/%y")
trees.bind$`Date Planted` <- as.Date(trees.bind$`Date Planted`,"%m/%d/%y")
trees.bind <- trees.bind %>% 
  mutate(`Planted Growth Days`=`Date Measured`-`Date Planted`)

trees <- trees.bind
```

## Data Quality Control
```{r}
dead.trees <- trees %>%
  filter(Health == "Dead")

matching.trees <- trees %>%
  inner_join(dead.trees, by = "Tree Number", relationship = "many-to-many")

#if previous year's health condition is dead change following years health condition to dead
trees <- trees %>%
  group_by(`Tree Number`, Site, `Seed Zone`) %>%
  arrange(Measurement.Year) %>%
  mutate(Previous_Value = lag(Health), Health = case_when(!is.na(Previous_Value) &
  Previous_Value == "Dead" ~ "Dead", TRUE ~ Health)) %>%
  select(-Previous_Value)

#if previous year's health condition is dying and current year's health condition is missing, change current year's health condition to dead
trees <- trees %>%
  group_by(`Tree Number`, Site, `Seed Zone`) %>%
  mutate(Health = case_when(lag(Health, n= 1, order_by = Measurement.Year) == "Dying" &
  Health == "Missing" ~ "Dead", TRUE ~ Health))

trees <- trees %>%
  group_by(`Tree Number`, Site, `Seed Zone`) %>%
  arrange(Measurement.Year) %>%
  mutate(Previous.Health = lag(Health), Health = case_when(is.na(Health) ~ Previous.Health, TRUE ~ Health)) %>%
  select(-Previous.Health)

#create final health column and if most current year's health condition is missing. use previous year's
trees <- trees %>%
  group_by(`Tree Number`, Site, `Seed Zone`) %>%
  tidyr::complete(Measurement.Year = seq(min(Measurement.Year), max(Measurement.Year)), fill = list(Health = NA)) %>%
  mutate(Final.Health = last(Health)) %>%
  mutate(Final.Health = zoo::na.locf(Final.Health, na.rm =  FALSE, fromLast = TRUE)) %>%
  mutate(Final.Health = ifelse(is.na(Health) & is.na(Final.Health), NA, Final.Health)) %>%
  ungroup()

trees$Site <- as.factor(trees$Site)
trees$Seed.Zone <-as.factor(trees$`Seed Zone`)
trees$Health <- as.factor(trees$Health)
```




## Exported Data 







